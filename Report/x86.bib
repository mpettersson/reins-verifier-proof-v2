@INPROCEEDINGS{wartell12acsac,
  author = "Richard Wartell and Vishwath Mohan and Kevin W. Hamlen and Zhiqiang Lin",
  title = "Securing Untrusted Code via Compiler-Agnostic Binary Rewriting",
  booktitle= "Proceedings of the 28th Annual Computer Security Applications Conference (ACSAC)",
  address = "Orlando, Florida",
  month = "December",
  year = 2012,
  note = "forthcoming",
}

@INPROCEEDINGS{Yee09nativeclient:,
    author = {Bennet Yee and David Sehr and Gregory Dardyk and J. Bradley Chen and Robert Muth and Tavis Orm and Shiki Okasaka and Neha Narula and Nicholas Fullagar and Google Inc},
    title = {Native Client: A Sandbox for Portable, Untrusted x86 Native Code},
    booktitle = {In Proceedings of the 2007 IEEE Symposium on Security and Privacy},
    year = {2009}
}

@inproceedings{MorrisettTTTG12,
  author = {Morrisett, Greg and Tan, Gang and Tassarotti, Joseph and Tristan, Jean-Baptiste and Gan, Edward},
  title = {RockSalt: better, faster, stronger SFI for the x86},
  booktitle = {Proceedings of the 33rd ACM SIGPLAN conference on Programming Language Design and Implementation},
  series = {PLDI '12},
  year = {2012},
  isbn = {978-1-4503-1205-9},
  location = {Beijing, China},
  pages = {395--404},
  numpages = {10},
  url = {http://doi.acm.org/10.1145/2254064.2254111},
  doi = {10.1145/2254064.2254111},
  acmid = {2254111},
  publisher = {ACM},
  address = {New York, NY, USA},
  keywords = {domain-specific languages, software fault isolation},
  abstract = {
    Software-based fault isolation (SFI), as used in Google's Native Client (NaCl),
    relies upon a conceptually simple machine-code analysis to enforce a security 
    policy.  But for complicated architectures such as the x86, it is all too easy
    to get the details of the analysis wrong.  We have built a new checker that is
    smaller, faster, and has a much reduced trusted computing base when compared
    to Google's original analysis.  The key to our approach is automatically 
    generating the bulk of the analysis from a declarative description which we
    relate to a formal model of a subset of the x86 instruction architecture. 
    The x86 model, developed in Coq, is of independent interest and should be
    usable for a wide range of machine-level verification tasks.}
}

@inproceedings{McCamantM06,
  author = {McCamant, Stephen and Morrisett, Greg},
  title = {Evaluating SFI for a CISC architecture},
  booktitle = {Proceedings of the 15th conference on USENIX Security Symposium - Volume 15},
  series = {USENIX-SS'06},
  year = {2006},
  location = {Vancouver, B.C., Canada},
  articleno = {15},
  url = {http://dl.acm.org/citation.cfm?id=1267336.1267351},
  acmid = {1267351},
  publisher = {USENIX Association},
  address = {Berkeley, CA, USA},
  abstract = {Executing untrusted code while preserving security requires that the code be prevented from modifying memory or executing instructions except as explicitly allowed. Software-based fault isolation (SFI) or "sandboxing" enforces such a policy by rewriting the untrusted code at the instruction level. However, the original sandboxing technique of Wahbe et al. is applicable only to RISC architectures, and most other previous work is either insecure, or has been not described in enough detail to give confidence in its security properties. We present a new sandboxing technique that can be applied to a CISC architecture like the IA-32, and whose application can be checked at load-time to minimize the TCB. We describe an implementation which provides a robust security guarantee and has low runtime overheads (an average of 21\% on the SPECint2000 benchmarks). We evaluate the utility of the technique by applying it to untrusted decompression modules in an archive tool, and its safety by constructing a machine-checked proof that any program approved by the verification algorithm will respect the desired safety property.},
  pdf = {http://people.csail.mit.edu/smcc/projects/pittsfield/pubs/usenix-sec-2006/pittsfield-usenix2006.pdf}
}

@MISC{Coq:Misc,
  author = {Coq development team},
  title = {The Coq proof assistant},
  year = {1989-2012},
  howpublished={\url{http://coq.inria.fr/}}
}

@MISC{GoNative:Misc,
  author = {GoNative Participants},
  title = {GoNative Safe Execution of Native Code},
  year = {2012},
  howpublished={\url{http://sos.cse.lehigh.edu/gonative/index.html}}
}

@MISC{Leroy:Misc,
  author = {Xavier Leroy},
  title = {},
  year = {2012},
  howpublished={\url{http://pauillac.inria.fr/~xleroy/}}
}

@MISC{Tassarotti:Misc,
  author = {Joseph Tassarotti},
  title = {},
  year = {2012},
  howpublished={\url{http://pauillac.inria.fr/~xleroy/}}
}

@TECHREPORT{Pietrek,
  AUTHOR =        {Matt Pietrek},
  TITLE =         {Peering Inside the PE: A Tour of the Win32 Portable Executable File Format},
  NUMBER =        {Vol.9 No.3},
  INSTITUTION =   {Microsoft Systems Journal},
  ADDRESS =       {},
  ABSTRACT =      {},
  KEYWORDS =      {},
  NOTE =          {},
  MONTH =         {March},
  YEAR  =         {1994},
  AUTHOR1_URL =   {http://www.wheaty.net/},
  AUTHOR1_EMAIL = {mattp@wheaty.net},
  PAGES =         {},
  FILE  =         {},
  URL   =         {http://msdn.microsoft.com/en-us/library/ms809762.aspx},
  CONTACT =       {}
}

@misc{pecoff:standard,
  title         = "Microsoft Portable Executable and Common Object File Format Specification",
  author        = "Microsoft",
  address       = "Redmond, WA",
  number        = "6.0",
  year          = "1999"
}

@manual{intelManual,
  title = {Intel 64 and IA-32 Architectures Software Developer's Manual},
  edition = {325462-042US},
  author = {Intel Corporation},
  year = 2012, mon = March,
}

@article{Leroy-Compcert-CACM,
  author = {Xavier Leroy},
  title = {Formal verification of a realistic compiler},
  journal = {Communications of the ACM},
  year = 2009,
  volume = 52,
  number = 7,
  pages = {107--115},
  url = {http://gallium.inria.fr/~xleroy/publi/compcert-CACM.pdf},
  urlpublisher = {http://doi.acm.org/10.1145/1538788.1538814},
  hal = {http://hal.archives-ouvertes.fr/inria-00415861/},
  pubkind = {journal-int-mono},
  abstract = {This paper reports on the development and formal verification (proof
  of semantic preservation) of CompCert, a compiler from Clight (a
  large subset of the C programming language) to PowerPC assembly code,
  using the Coq proof assistant both for programming the compiler and
  for proving its correctness.  Such a verified compiler is useful in
  the context of critical software and its formal verification: the
  verification of the compiler guarantees that the safety properties
  proved on the source code hold for the executable compiled code as
  well.}
}

@MISC{PE:Misc,
  author = {The Collaborative RCE Tool Library Team},
  title = {Collaborative RCE Tool Library},
  year = {2012},
  howpublished={\url{http://www.openrce.org/reference_library/files/reference/PE\%20Format.pdf}}
}

@article{Wahbe:1993:ESF:173668.168635,
 author = {Wahbe, Robert and Lucco, Steven and Anderson, Thomas E. and Graham, Susan L.},
 title = {Efficient software-based fault isolation},
 journal = {SIGOPS Oper. Syst. Rev.},
 issue_date = {Dec. 1993},
 volume = {27},
 number = {5},
 month = dec,
 year = {1993},
 issn = {0163-5980},
 pages = {203--216},
 numpages = {14},
 url = {http://doi.acm.org/10.1145/173668.168635},
 doi = {10.1145/173668.168635},
 acmid = {168635},
 publisher = {ACM},
 address = {New York, NY, USA},
} 

